// Generated by CoffeeScript 1.6.3
var DEBUG, a2a, alambda, an1, an2, an3, borderConf, elements, getCoeff, globalConf, gridPoint, grids, indicatingString, initialize, iterateAll, iterateAllOnce, iterateSolve, iterateToEnough, maxVal, minVal, modeSolve, paraExample, plotData, recolorAll, results, viewTimePoint, viewbackTo,
  _this = this;

elements = {};

iterateSolve = function(range, func, initGuess, tolarence) {
  var delta, error, guess, iterCount, nextGuess, slope, y1, y2;
  error = 100;
  iterCount = 0;
  guess = initGuess;
  delta = 1e-3;
  while (error > tolarence && iterCount < 1000) {
    y1 = func(guess);
    y2 = func(guess * (1 + delta));
    slope = (y2 - y1) / delta;
    console.warn(guess);
    console.warn(slope);
    if (slope !== 0 && y1 !== 0) {
      nextGuess = guess - y1 / slope;
      error = 2 * (guess - nextGuess) / (guess + nextGuess) * 100;
      error = Math.abs(error);
    } else if (y1 = 0) {
      return guess;
    } else {
      console.warn("Unexpected error, slope = 0");
      return "";
    }
    guess = nextGuess;
    iterCount = iterCount + 1;
    console.warn("error:", error);
  }
  if (iterCount < 1000) {
    return guess;
  } else {
    return '';
  }
};

modeSolve = function(para) {
  var a, f, i, lambda, modeMax, n1, n2, n3, result, theta, thetaC2, thetaC3, _i, _j;
  n1 = para.n1;
  n2 = para.n2;
  n3 = para.n3;
  a = para['2a'] / 2;
  lambda = para.lambda;
  if (DEBUG) {
    console.info(para);
  }
  thetaC2 = Math.asin(n2 / n1);
  thetaC3 = Math.asin(n3 / n1);
  modeMax = Math.floor(4 * a / lambda * n1 * Math.cos(Math.max(thetaC2, thetaC3)));
  result = {
    'TE': {},
    'TM': {}
  };
  result['modeMax'] = modeMax;
  for (i = _i = 0; 0 <= modeMax ? _i <= modeMax : _i >= modeMax; i = 0 <= modeMax ? ++_i : --_i) {
    f = function(x) {
      return 4 * a * (2 * Math.PI / lambda) * n1 * Math.cos(x) - 2 * Math.atan(Math.sqrt(n1 * n1 * Math.sin(x) * Math.sin(x) - n2 * n2) / (n1 * Math.cos(x))) - 2 * Math.atan(Math.sqrt(n1 * n1 * Math.sin(x) * Math.sin(x) - n3 * n3) / (n1 * Math.cos(x))) - 2 * Math.PI * i;
    };
    theta = iterateSolve([], f, Math.PI / 2 - 0.1, 0.000001);
    result['TE']['TE' + i] = {};
    result['TE']['TE' + i]['theta'] = theta;
    result['TE']['TE' + i]['thetaD'] = theta / Math.PI * 180;
    console.info(theta / Math.PI * 180);
  }
  for (i = _j = 0; 0 <= modeMax ? _j <= modeMax : _j >= modeMax; i = 0 <= modeMax ? ++_j : --_j) {
    f = function(x) {
      return 4 * a * (2 * Math.PI / lambda) * n1 * Math.cos(x) - 2 * Math.atan(n1 * n1 / (n2 * n2) * Math.sqrt(n1 * n1 * Math.sin(x) * Math.sin(x) - n2 * n2) / (n1 * Math.cos(x))) - 2 * Math.atan(n1 * n1 / (n3 * n3) * Math.sqrt(n1 * n1 * Math.sin(x) * Math.sin(x) - n3 * n3) / (n1 * Math.cos(x))) - 2 * Math.PI * i;
    };
    theta = iterateSolve([], f, Math.PI / 2 - 0.1, 0.000001);
    result['TM']['TM' + i] = {};
    result['TM']['TM' + i]['theta'] = theta;
    result['TM']['TM' + i]['thetaD'] = theta / Math.PI * 180;
    console.info(theta / Math.PI * 180);
  }
  if (DEBUG) {
    console.info(thetaC2, thetaC3, modeMax);
  }
  return result;
};

getCoeff = function(bdConf, x, y, direction, timeStep) {
  if (direction == null) {
    direction = 0;
  }
  if (timeStep == null) {
    timeStep = 0;
  }
  switch (bdConf.type) {
    case 1:
      return [1e30 * bdConf.temp(timeStep), -1e30];
    case 2:
      switch (direction) {
        case 0:
          return [bdConf.coeff * globalConf.deltaY, 0];
        case 1:
          return [bdConf.coeff * globalConf.deltaX, 0];
      }
      break;
    case 3:
      switch (direction) {
        case 0:
          return [bdConf.temp(timeStep) * bdConf.coeff * globalConf.deltaY, -bdConf.coeff * globalConf.deltaY];
        case 1:
          return [bdConf.temp(timeStep) * bdConf.coeff * globalConf.deltaX, -bdConf.coeff * globalConf.deltaX];
      }
  }
};

borderConf = (function() {
  function borderConf(type, temp, coeff) {
    this.type = type;
    this.temp = temp;
    this.coeff = coeff;
  }

  return borderConf;

})();

gridPoint = (function() {
  function gridPoint(x, y) {
    var generateStr;
    this.x = x;
    this.y = y;
    generateStr = '<div id="grid_' + this.x + '_' + this.y + '" class="singleGrid"></div>';
    this.divObject = $(generateStr).appendTo($("body")[0]);
    if (this.x === 1) {
      this.divObject.css("left", (this.x - 1) * globalConf.deltaX * globalConf.zoom + 100);
      this.divObject.css("width", globalConf.deltaX * globalConf.zoom / 2);
    } else if (this.x === globalConf.gridX) {
      this.divObject.css("left", (this.x - 1.5) * globalConf.deltaX * globalConf.zoom + 100);
      this.divObject.css("width", globalConf.deltaX * globalConf.zoom / 2);
    } else {
      this.divObject.css("left", (this.x - 1.5) * globalConf.deltaX * globalConf.zoom + 100);
      this.divObject.css("width", globalConf.deltaX * globalConf.zoom);
    }
    if (this.y === globalConf.gridY) {
      this.divObject.css("top", (globalConf.gridY - this.y) * globalConf.deltaY * globalConf.zoom + 100);
      this.divObject.css("height", globalConf.deltaY * globalConf.zoom / 2);
    } else if (this.y === 1) {
      this.divObject.css("top", (globalConf.gridY - this.y - 0.5) * globalConf.deltaY * globalConf.zoom + 100);
      this.divObject.css("height", globalConf.deltaY * globalConf.zoom / 2);
    } else {
      this.divObject.css("top", (globalConf.gridY - this.y - 0.5) * globalConf.deltaY * globalConf.zoom + 100);
      this.divObject.css("height", globalConf.deltaY * globalConf.zoom);
    }
    this.history = [[0]];
    this.iterTime = [0];
    this.current = 10;
    this.timeStepElapsed = 0;
  }

  gridPoint.prototype.iterateOnce = function(timeStep) {
    var ab, al, ar, at, bb, bl, br, bt, c, d, goodEnough, _ref, _ref1, _ref2, _ref3;
    if (timeStep == null) {
      timeStep = 0;
    }
    if (!(this.history[timeStep] != null)) {
      this.history[timeStep] = [0];
    }
    if (!(this.iterTime[timeStep] != null)) {
      this.iterTime[timeStep] = 0;
    }
    if (timeStep !== 0) {
      c = -this.history[timeStep - 1][this.iterTime[timeStep - 1]] * globalConf.deltaY * globalConf.deltaX / (2 * globalConf.a * globalConf.deltaT);
      d = globalConf.deltaY * globalConf.deltaX / (2 * globalConf.a * globalConf.deltaT);
    } else {
      c = 0;
      d = 0;
    }
    if (this.x === 1) {
      _ref = getCoeff(globalConf.borders.left, this.x, this.y, 0, timeStep), al = _ref[0], bl = _ref[1];
      ar = globalConf.lambda * globalConf.deltaY / globalConf.deltaX * grids[this.x + 1][this.y].getNewest(timeStep);
      br = -globalConf.lambda * globalConf.deltaY / globalConf.deltaX;
    } else if (this.x === globalConf.gridX) {
      _ref1 = getCoeff(globalConf.borders.right, this.x, this.y, 0, timeStep), ar = _ref1[0], br = _ref1[1];
      al = globalConf.lambda * globalConf.deltaY / globalConf.deltaX * grids[this.x - 1][this.y].getNewest(timeStep);
      bl = -globalConf.lambda * globalConf.deltaY / globalConf.deltaX;
    } else {
      al = globalConf.lambda * globalConf.deltaY / globalConf.deltaX * grids[this.x - 1][this.y].getNewest(timeStep);
      bl = -globalConf.lambda * globalConf.deltaY / globalConf.deltaX;
      ar = globalConf.lambda * globalConf.deltaY / globalConf.deltaX * grids[this.x + 1][this.y].getNewest(timeStep);
      br = -globalConf.lambda * globalConf.deltaY / globalConf.deltaX;
    }
    if (this.y === 1 || this.y === globalConf.gridY) {
      al /= 2;
      ar /= 2;
      bl /= 2;
      br /= 2;
      c /= 2;
      d /= 2;
    }
    if (this.y === 1) {
      _ref2 = getCoeff(globalConf.borders.bottom, this.x, this.y, 1, timeStep), at = _ref2[0], bt = _ref2[1];
      ab = globalConf.lambda * globalConf.deltaX / globalConf.deltaY * grids[this.x][this.y + 1].getNewest(timeStep);
      bb = -globalConf.lambda * globalConf.deltaX / globalConf.deltaY;
    } else if (this.y === globalConf.gridY) {
      _ref3 = getCoeff(globalConf.borders.top, this.x, this.y, 1, timeStep), ab = _ref3[0], bb = _ref3[1];
      at = globalConf.lambda * globalConf.deltaX / globalConf.deltaY * grids[this.x][this.y - 1].getNewest(timeStep);
      bt = -globalConf.lambda * globalConf.deltaX / globalConf.deltaY;
    } else {
      ab = globalConf.lambda * globalConf.deltaX / globalConf.deltaY * grids[this.x][this.y + 1].getNewest(timeStep);
      bb = -globalConf.lambda * globalConf.deltaX / globalConf.deltaY;
      at = globalConf.lambda * globalConf.deltaX / globalConf.deltaY * grids[this.x][this.y - 1].getNewest(timeStep);
      bt = -globalConf.lambda * globalConf.deltaX / globalConf.deltaY;
    }
    if (this.x === 1 || this.x === globalConf.gridX) {
      at /= 2;
      bt /= 2;
      bb /= 2;
      ab /= 2;
      c /= 2;
      d /= 2;
    }
    this.iterTime[timeStep] += 1;
    this.history[timeStep][this.iterTime[timeStep]] = -(al + ar + at + ab - c) / (bl + br + bt + bb - d);
    this.current = this.history[timeStep][this.iterTime[timeStep]];
    if (Math.abs(this.history[timeStep][this.iterTime[timeStep]] - this.history[timeStep][this.iterTime[timeStep] - 1]) < globalConf.errorMax) {
      goodEnough = true;
    } else {
      goodEnough = false;
    }
    return goodEnough;
  };

  gridPoint.prototype.rollbackTo = function(time) {
    this.divObject[0].innerHTML = this.history[time];
    return this.current = this.history[time];
  };

  gridPoint.prototype.updateDisplayData = function() {
    return this.divObject[0].innerHTML = this.current;
  };

  gridPoint.prototype.getCurrent = function() {
    return this.current;
  };

  gridPoint.prototype.setCurrent = function(timeFrame) {
    return this.current = this.history[timeFrame][this.iterTime[timeFrame]];
  };

  gridPoint.prototype.getNewest = function(timeStep) {
    if (!(this.history[timeStep] != null)) {
      this.history[timeStep] = [0];
    }
    if (!(this.iterTime[timeStep] != null)) {
      this.iterTime[timeStep] = 0;
    }
    return this.history[timeStep][this.iterTime[timeStep]];
  };

  return gridPoint;

})();

globalConf = {
  "deltaX": 0.01,
  "deltaY": 0.01,
  "zoom": 4000,
  "gridX": 25,
  "gridY": 5,
  "borders": {
    "left": new borderConf(3, (function(timeStep) {
      return 22;
    }), 6),
    "right": new borderConf(3, (function(timeStep) {
      return 5 + 10 * Math.sin(0.2618 * timeStep * globalConf.deltaT);
    }), 25),
    "top": new borderConf(2, 0, 0),
    "bottom": new borderConf(2, 0, 0)
  },
  "errorMax": 0.0005,
  "lambda": 1,
  "a": 3.17e-3,
  "deltaT": 0.1
};

grids = [[]];

iterateAllOnce = function(timeStep) {
  var i, j, _i, _ref, _results;
  _results = [];
  for (i = _i = 1, _ref = globalConf.gridX; 1 <= _ref ? _i <= _ref : _i >= _ref; i = 1 <= _ref ? ++_i : --_i) {
    _results.push((function() {
      var _j, _ref1, _results1;
      _results1 = [];
      for (j = _j = 1, _ref1 = globalConf.gridY; 1 <= _ref1 ? _j <= _ref1 : _j >= _ref1; j = 1 <= _ref1 ? ++_j : --_j) {
        _results1.push((function(i, j) {
          return grids[i][j].iterateOnce(timeStep);
        })(i, j));
      }
      return _results1;
    })());
  }
  return _results;
};

iterateAll = function(times) {
  var i, j, k, _i, _results;
  _results = [];
  for (k = _i = 1; 1 <= times ? _i <= times : _i >= times; k = 1 <= times ? ++_i : --_i) {
    if (k % 1000 === 0) {
      recolorAll();
    }
    _results.push((function() {
      var _j, _ref, _results1;
      _results1 = [];
      for (i = _j = 1, _ref = globalConf.gridX; 1 <= _ref ? _j <= _ref : _j >= _ref; i = 1 <= _ref ? ++_j : --_j) {
        _results1.push((function() {
          var _k, _ref1, _results2;
          _results2 = [];
          for (j = _k = 1, _ref1 = globalConf.gridY; 1 <= _ref1 ? _k <= _ref1 : _k >= _ref1; j = 1 <= _ref1 ? ++_k : --_k) {
            _results2.push(grids[i][j].iterateOnce());
          }
          return _results2;
        })());
      }
      return _results1;
    })());
  }
  return _results;
};

maxVal = 0;

minVal = 1e10;

recolorAll = function() {
  var i, j, _fn, _i, _j, _k, _ref, _ref1, _ref2, _results;
  maxVal = 0;
  minVal = 10e10;
  for (i = _i = 1, _ref = globalConf.gridX; 1 <= _ref ? _i <= _ref : _i >= _ref; i = 1 <= _ref ? ++_i : --_i) {
    _fn = function(i, j) {
      maxVal = grids[i][j].getCurrent() > maxVal ? grids[i][j].getCurrent() : maxVal;
      return minVal = grids[i][j].getCurrent() < minVal ? grids[i][j].getCurrent() : minVal;
    };
    for (j = _j = 1, _ref1 = globalConf.gridY; 1 <= _ref1 ? _j <= _ref1 : _j >= _ref1; j = 1 <= _ref1 ? ++_j : --_j) {
      _fn(i, j);
    }
  }
  _results = [];
  for (i = _k = 1, _ref2 = globalConf.gridX; 1 <= _ref2 ? _k <= _ref2 : _k >= _ref2; i = 1 <= _ref2 ? ++_k : --_k) {
    _results.push((function() {
      var _l, _ref3, _results1;
      _results1 = [];
      for (j = _l = 1, _ref3 = globalConf.gridY; 1 <= _ref3 ? _l <= _ref3 : _l >= _ref3; j = 1 <= _ref3 ? ++_l : --_l) {
        _results1.push((function(i, j) {
          var B, R;
          R = Math.round((grids[i][j].getCurrent() - minVal) / (maxVal - minVal) * 200 + 55);
          B = Math.round(200 - (grids[i][j].getCurrent() - minVal) / (maxVal - minVal) * 200);
          return grids[i][j].divObject.css("backgroundColor", "RGB(" + R + ",0," + B + ")");
        })(i, j));
      }
      return _results1;
    })());
  }
  return _results;
};

viewbackTo = function(iterTime) {
  var i, j, _i, _ref, _results;
  _results = [];
  for (i = _i = 1, _ref = globalConf.gridX; 1 <= _ref ? _i <= _ref : _i >= _ref; i = 1 <= _ref ? ++_i : --_i) {
    _results.push((function() {
      var _j, _ref1, _results1;
      _results1 = [];
      for (j = _j = 1, _ref1 = globalConf.gridY; 1 <= _ref1 ? _j <= _ref1 : _j >= _ref1; j = 1 <= _ref1 ? ++_j : --_j) {
        grids[i][j].rollbackTo(iterTime);
        _results1.push(recolorAll());
      }
      return _results1;
    })());
  }
  return _results;
};

viewTimePoint = function(timeFrame) {
  var i, j, _i, _j, _ref, _ref1;
  for (i = _i = 1, _ref = globalConf.gridX; 1 <= _ref ? _i <= _ref : _i >= _ref; i = 1 <= _ref ? ++_i : --_i) {
    for (j = _j = 1, _ref1 = globalConf.gridY; 1 <= _ref1 ? _j <= _ref1 : _j >= _ref1; j = 1 <= _ref1 ? ++_j : --_j) {
      grids[i][j].setCurrent(timeFrame);
      grids[i][j].updateDisplayData();
    }
  }
  return recolorAll();
};

iterateToEnough = function(timeFrame, maxTime) {
  var accurateEnough, i, j, k, __t, _i, _j, _k, _l, _m, _n, _o, _ref, _ref1, _ref2, _ref3, _ref4, _ref5;
  accurateEnough = false;
  for (k = _i = 1; 1 <= maxTime ? _i <= maxTime : _i >= maxTime; k = 1 <= maxTime ? ++_i : --_i) {
    if (accurateEnough) {
      for (i = _j = 1, _ref = globalConf.gridX; 1 <= _ref ? _j <= _ref : _j >= _ref; i = 1 <= _ref ? ++_j : --_j) {
        for (j = _k = 1, _ref1 = globalConf.gridY; 1 <= _ref1 ? _k <= _ref1 : _k >= _ref1; j = 1 <= _ref1 ? ++_k : --_k) {
          grids[i][j].updateDisplayData();
        }
      }
      recolorAll();
      return k;
    }
    accurateEnough = true;
    for (i = _l = 1, _ref2 = globalConf.gridX; 1 <= _ref2 ? _l <= _ref2 : _l >= _ref2; i = 1 <= _ref2 ? ++_l : --_l) {
      for (j = _m = 1, _ref3 = globalConf.gridY; 1 <= _ref3 ? _m <= _ref3 : _m >= _ref3; j = 1 <= _ref3 ? ++_m : --_m) {
        __t = true === grids[i][j].iterateOnce(timeFrame);
        accurateEnough = __t;
      }
    }
  }
  recolorAll();
  for (i = _n = 1, _ref4 = globalConf.gridX; 1 <= _ref4 ? _n <= _ref4 : _n >= _ref4; i = 1 <= _ref4 ? ++_n : --_n) {
    for (j = _o = 1, _ref5 = globalConf.gridY; 1 <= _ref5 ? _o <= _ref5 : _o >= _ref5; j = 1 <= _ref5 ? ++_o : --_o) {
      grids[i][j].updateDisplayData();
    }
  }
  return -1;
};

initialize = function() {
  var i, j, _fn, _i, _j, _k, _ref, _ref1, _results;
  $(".singleGrid").remove();
  grids = [];
  for (i = _i = 1, _ref = globalConf.gridX; 1 <= _ref ? _i <= _ref : _i >= _ref; i = 1 <= _ref ? ++_i : --_i) {
    _fn = function(i, j) {
      if (grids[i] == null) {
        grids[i] = [];
      }
      return grids[i][j] = new gridPoint(i, j);
    };
    for (j = _j = 1, _ref1 = globalConf.gridY; 1 <= _ref1 ? _j <= _ref1 : _j >= _ref1; j = 1 <= _ref1 ? ++_j : --_j) {
      _fn(i, j);
    }
  }
  _results = [];
  for (i = _k = 0; _k <= 60; i = ++_k) {
    _results.push(iterateToEnough(i, 50000));
  }
  return _results;
};

paraExample = {
  'n1': 2.5,
  'n2': 1.2,
  'n3': 1.5,
  'lambda': 632.8,
  '2a': 200
};

results = [];

plotData = [];

DEBUG = true;

an1 = an2 = an3 = alambda = a2a = 0;

indicatingString = '';

$(function() {
  var data, i, mainHandler, options, r;
  DEBUG = true;
  r = modeSolve(paraExample);
  data = {
    'labels': (function() {
      var _i, _ref, _results;
      _results = [];
      for (i = _i = 0, _ref = r['modeMax']; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
        _results.push('TX' + i);
      }
      return _results;
    })(),
    "datasets": [
      {
        'label': 'TE',
        "data": (function() {
          var _i, _ref, _results;
          _results = [];
          for (i = _i = 0, _ref = r['modeMax']; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
            _results.push(r['TE']['TE' + i]['thetaD']);
          }
          return _results;
        })()
      }
    ]
  };
  options = {
    datasetFill: true
  };
  console.info(data, options);
  mainHandler = function() {
    var TX, lambda, n1, n2, n3, once, result, tempPara, _2a, _i, _j, _k, _l, _len, _len1, _len2, _len3, _len4, _len5, _len6, _m, _n, _o, _p, _ref, _ref1, _ref2;
    an1 = eval(calculatePara['n1'].value);
    if (!an1.hasOwnProperty("length")) {
      an1 = [an1];
    }
    an2 = eval(calculatePara['n2'].value);
    if (!an2.hasOwnProperty("length")) {
      an2 = [an2];
    }
    an3 = eval(calculatePara['n3'].value);
    if (!an3.hasOwnProperty("length")) {
      an3 = [an3];
    }
    alambda = eval(calculatePara['lambda'].value);
    if (!alambda.hasOwnProperty("length")) {
      alambda = [alambda];
    }
    a2a = eval(calculatePara['2a'].value);
    if (!a2a.hasOwnProperty("length")) {
      a2a = [a2a];
    }
    _ref = ["TE", "TM"];
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      TX = _ref[_i];
      $("#result" + TX)[0].innerHTML = '';
    }
    tempPara = {};
    console.info("!");
    for (_j = 0, _len1 = an1.length; _j < _len1; _j++) {
      n1 = an1[_j];
      for (_k = 0, _len2 = an2.length; _k < _len2; _k++) {
        n2 = an2[_k];
        for (_l = 0, _len3 = an3.length; _l < _len3; _l++) {
          n3 = an3[_l];
          for (_m = 0, _len4 = alambda.length; _m < _len4; _m++) {
            lambda = alambda[_m];
            for (_n = 0, _len5 = a2a.length; _n < _len5; _n++) {
              _2a = a2a[_n];
              tempPara = {
                'n1': n1,
                'n2': n2,
                'n3': n3,
                'lambda': lambda,
                '2a': _2a
              };
              result = modeSolve(tempPara);
              once = result;
              _ref1 = ["TE", "TM"];
              for (_o = 0, _len6 = _ref1.length; _o < _len6; _o++) {
                TX = _ref1[_o];
                $("#result" + TX)[0].innerHTML = $("#result" + TX)[0].innerHTML + "" + 3e17 / lambda + "," + n1 + ',' + n2 + ',' + n3 + ',' + _2a + ',';
                for (i = _p = 0, _ref2 = once['modeMax']; 0 <= _ref2 ? _p <= _ref2 : _p >= _ref2; i = 0 <= _ref2 ? ++_p : --_p) {
                  $("#result" + TX)[0].innerHTML = $("#result" + TX)[0].innerHTML + (once[TX][TX + i] != null ? Math.sin(once[TX][TX + i]['theta']) * Math.PI * 2 / lambda * n1 : NaN);
                  $("#result" + TX)[0].innerHTML = $("#result" + TX)[0].innerHTML + ',';
                }
                $("#result" + TX)[0].innerHTML = $("#result" + TX)[0].innerHTML + '<br>';
              }
            }
          }
        }
      }
    }
    $(btnCalMode)[0].innerHTML = indicatingString;
    return $(btnCalMode)[0].disabled = false;
  };
  return $(btnCalMode)[0].addEventListener('click', function() {
    indicatingString = $(btnCalMode)[0].innerHTML;
    $(btnCalMode)[0].innerHTML = '<span style="background:black;color:black;text-shadow:none"><del>少女</del></span>祈祷中...';
    $(btnCalMode)[0].disabled = true;
    return setTimeout(mainHandler, 50);
  });
});

/*
//@ sourceMappingURL=webOG.map
*/
